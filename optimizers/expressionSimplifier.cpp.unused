
#include <filesystem>
#include <iostream>
#include <vector>
#include <sstream>
#include <fstream>
#include <format>
#include <cstring>

#include "../syntax_tree_nodes.hpp"

using namespace std;

template <typename T>
struct reversion_wrapper { T& iterable; };

template <typename T>
auto begin (reversion_wrapper<T> w) { return std::rbegin(w.iterable); }

template <typename T>
auto end (reversion_wrapper<T> w) { return std::rend(w.iterable); }

template <typename T>
reversion_wrapper<T> reverse (T&& iterable) { return { iterable }; }

string readfile (ifstream& in) {
    stringstream buf;

    buf << in.rdbuf();
    in.close();

    return buf.str();
}

struct input_params{
    ifstream* in_stream;
    bool out_is_file;
    ofstream* out_stream;
    bool human;
};

void parse_args(int& argc, char* argv[], input_params& par){

    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " infile [-o outfile] [-h]\n";
        cerr << "  infile      path to input file\n";
        cerr << "  -o outfile  path to output file\n";
        cerr << "  -h          output in a human readable way\n";
        throw invalid_argument("No input file specified");
    }

    if (!filesystem::is_regular_file(argv[1]) && !filesystem::is_symlink(argv[1])){
        cerr << "Usage: " << argv[0] << " infile [-o outfile] [-h]\n";
        cerr << "  infile      path to input file\n";
        cerr << "  -o outfile  path to output file\n";
        cerr << "  -h          output in a human readable way\n";
        throw invalid_argument("Input file does not refer to a file");
    }

    ifstream* in = new ifstream(argv[1]);

    if (in->fail()){
        cerr << "Usage: " << argv[0] << " infile [-o outfile] [-h]\n";
        cerr << "  infile      path to input file\n";
        cerr << "  -o outfile  path to output file\n";
        cerr << "  -h          output in a human readable way\n";
        throw invalid_argument("Could not open input file");
    }

    par.in_stream = in;
    par.out_stream = nullptr;
    par.out_is_file = false;
    par.human = false;

    int y = 2;

    while (y != argc) {
        if (strcmp(argv[y], "-o") == 0) {
            if (y + 1 == argc){
                cerr << "Usage: " << argv[0] << " infile [-o outfile] [-h]\n";
                cerr << "  infile      path to input file\n";
                cerr << "  -o outfile  path to output file\n";
                cerr << "  -h          output in a human readable way\n";
                throw invalid_argument("No output file after flag");
            }

            ofstream* out = new ofstream(argv[y+1]);

            if (out->fail()) {
                cerr << "Usage: " << argv[0] << " infile [-o outfile] [-h]\n";
                cerr << "  infile      path to input file\n";
                cerr << "  -o outfile  path to output file\n";
                cerr << "  -h          output in a human readable way\n";
                throw invalid_argument("Could not open output file");
            }

            par.out_stream = out;
            par.out_is_file = true;
            ++y;

        } else if (strcmp(argv[y], "-h") == 0) {
            par.human = true;
        }
        ++y;
    }
}

int nodes = 0;

bool prev_foo = false;

struct AmbiguousValue{
    char type = '#';

    long long int_val;
    long double real_val;
    bool bool_val;
    std::string string_val;
};

map<int, AmbiguousValue> explvals


void at_exit (Node* node) {
    void at_enter (Node* node) {
    ++nodes;

    ExpressionNode* expr_node = dynamic_cast<ExpressionNode*>(node);
    RelationNode* rel_node = dynamic_cast<RelationNode*>(node);
    TermNode* term_node = dynamic_cast<TermNode*>(node);
    FactorNode* fact_node = dynamic_cast<FactorNode*>(node);
    UnaryNode* unar_node = dynamic_cast<UnaryNode*>(node);
    PrimaryNode* prim_node = dynamic_cast<PrimaryNode*>(node);
    LiteralNode* lit_node = dynamic_cast<LiteralNode*>(node);

    if (lit_node != nullptr) {
        expvals[node->id] = AmbiguousValue();
        if (lit_node->type == 'a' || lit_node->type == 't' || lit_node->type == 'f') return;
        expvals[node->id].type = lit_node->type;
        expvals[node->id].int_val = lit_node->int_val;
        expvals[node->id].real_val = lit_node->real_val;
        expvals[node->id].bool_val = lit_node->bool_val;
        expvals[node->id].string_val = lit_node->string_val;
    } else if (prim_node != nullptr) {
        expvals[node->id] = AmbiguousValue();
        if (prim_node->type != 'l') return;
        expvals[node->id] = expvals[prim_node->literal->id];
    } else if (unar_node != nullptr) {
        expvals[node->id] = AmbiguousValue();

        if(unar_node->type == 'p') {
            switch (unar_node->unaryop) {
                case '+':

                    break;
                case '-':

                    break;
                case 'n':

                    break;
                case '#':

                    break;
            }
        } else if (unar_node->type == 'e') {

        } else return;
    } else if (fact_node != nullptr) {
        expvals[node->id] = AmbiguousValue();

    } else if (term_node != nullptr) {
        expvals[node->id] = AmbiguousValue();

    } else if (rel_node != nullptr) {
        expvals[node->id] = AmbiguousValue();

    } else if (expr_node != nullptr) {
        expvals[node->id] = AmbiguousValue();

    }

    return;
}
}


int main(int argc, char *argv[]) {
    input_params param;
    parse_args(argc, argv, param);

    Node* tree = readTree(*param.in_stream);

    //cout << "TREE ID: " << reinterpret_cast<std::uintptr_t>(tree) << endl;

    human_output_nodes = false;

    scope_wraps.push_back(-1);
    scopes.resize(1);

    tree->visit(at_enter1, dummy, at_exit);
    tree->visit(at_enter2, dummy, at_exit);
    reassign_ids(tree);

    if(param.out_is_file){
        (*param.out_stream) << tree;
        (*param.out_stream).close();
    } else {
        cout << tree;
    }
    //cout << "Total nodes: " << nodes << endl;
}
